# Ansible Best Practices

## Configuration

ansible.cfg should look like:

```
[defaults]
host_key_checking = False
hostfile = ./inventory
roles_path = ./roles
remote_tmp = /tmp

[ssh_connection]
pipelining = True
```

We use spaces and not tabs. Also, lines typically should not end with
whitespace. To make this obvious, the following at the end of ~/.vimrc
really helps:

```
highlight ExtraWhiteSpace ctermbg=red guibg=red
match ExtraWhiteSpace /\t/
autocmd InsertEnter * match ExtraWhiteSpace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhiteSpace /\s\+$/
```

To avoid the use of tabs, the following can also help:

```
set autoindent
set tabstop=2
set softtabstop=2
set shiftwidth=2
set expandtab
```

## Repository structure

```
playbooks/
|-- askbot
|   |-- devel
|   |   `-- deploy-devel-askbot.yml
|   |-- production
|   |   |-- deploy-prod-askbot.yml
|   |   |-- prod-askbot-passwords.yml
|   |   `-- upgrade-prod-askbot.yml
|   |-- README.md
|   `-- stage
|       |-- deploy-stage-askbot.yml
|       |-- stage-askbot-passwords.yml
|       `-- upgrade-stage-askbot.yml
|-- bugzilla
|   |-- devel
|   |   `-- deploy-devel-bugzilla.yml
|   |-- production
|   |   |-- deploy-production-bugzilla.yml
|   |   |-- production-bugzilla-passwords.yml
|   |   `-- README.md
|   |-- stage
|   |   |-- deploy-stage-bugzilla.yml
|   |   `-- stage-bugzilla-passwords.yml
|   `-- universal_update.yml
```

## Playbooks

* Upgrade playbooks should include a full configuration management state run
  in them, or at the very least, a full deploy configuration management run
  should be able to be run at any time without issues.
* Playbooks should not connect as the root user. They should connect as your
  user and elevate privileges when needed. To achieve this, the top of your
  playbook should look like:

  ```
  hosts: application-env
  remote_user: "{{lookup('env', 'USER')}}"
  become: True
  become_user: root
  ```

  Playbooks that contain tasks with `become: postgres` or similar (i.e.
  older `sudo: postgres`) may need to allow passwordless privilege escalation
  to that user

* Playbook indentation must be consistent, using either two spaces for 
  indentation or a hyphen and a space for the first line of list items, e.g.:

  ```
  - hosts: all

    roles:
    - role1
    - role2

    tasks:
    - name: write template
      template:
        src: foo.j2
        dest: /var/www/html/foo
  ```

* Playbooks should be simple and obviously similar across multiple
  environments, offloading their complexity to roles. This means that sections
  such as `pre_tasks`, `tasks`, `post_tasks` and `handlers` should be left
  to roles to manage, and sections such as `vars` should be left to inventory
  data.

* Use `vars_files` instead of `include_vars`, unless you are forced to use
  a role that uses `delegate_to: localhost` ([See related Ansible
  bug](https://github.com/ansible/ansible/pull/17965))

* Playbooks should not target `hosts: localhost` unless the playbook is only
  designed to perform actions against the local machine (e.g. a workstation
  configuration playbook). Using `hosts: localhost` reduces the availability
  of useful inventory data, and leads to excessive use of `vars`. Instead,
  create a target group, and provide the variables to that group, and
  use `connection: local`.

## Inventory

### Groups

* Groups should be named to take into consideration application, environment
  and component type.
* Group names should be prefixed with the application. Environment specific
  groups should be suffixed with the environment.
* Order is therefore application-component-environment
  e.g. bugzilla-web-qe.
* Ensure that inheritance hierarchies are correctly maintained through
  the use of child groups. `bugzilla-web-qe` would be a child of `bugzilla-web`
  and `bugzilla-qe`, and both would be children of `bugzilla` group.

e.g 

```
[bugzilla:children]
bugzilla-web
bugzilla-db
bugzilla-qe
bugzilla-dev

[bugzilla-web:children]
bugzilla-web-dev
bugzilla-web-qe

[bugzilla-qe:children]
bugzilla-web-qe
bugzilla-db-qe

[bugzilla-web-qe]
bugweb-01.qe.example.com
```

![bugzilla-web-qe structure](bugzilla-web-qe.png)


### Variables

* Variables should be set in an appropriate group in inventory/group_vars,
  or be set as role defaults or role variables.
* Host variables should be used only for things that will only be true
  for a single host.  An example of this might be caching ofa UUID of a host as
  part of a hub-worker identity management setup.
* Variables should not be stored in inventory host files (using [group:vars]
  mechanism) - the inventory files should be used for group contents and
  hierarchy definitions (using [group:children]). This is to avoid confusion
  about where variables might be set.
* Handling of non-sharable info is discussed in [secrets.md] .
* Variables and roles should be named with minimal abbreviations so as to
  increase consistency and avoid confusion (Principle of Least Surprise).
  Therefore, prefer `java_jvm_options` over `java_jvm_opts` (but not
  `java_java_virtual_machine_options`!), `password` over `pass`, etc.
  Common acronyms will generally be ok. In particular, prod, qe and devel are
  acceptable for environment names.


## Roles

Roles are for reusability and modularity, both within and outside of Pnt-DevOps.
If any section of a playbook (or role) might be used by one or more applications
or roles, it should be abstracted to a role.  Roles should not contain
deployment specific data.

For readability, separate each task or handler by a blank line.

Roles live under the
[ansible-roles](https://gitlab.infra.prod.eng.rdu2.redhat.com/ansible-roles)
group in gitlab.

Each role has its own repo, which means that it can be easily versioned
through git tagging. To add a version to a role:

```
git tag v0.x
git push origin v0.x
```

Roles should contain a globally unique identifier to allow adjacent roles to
detect and make decisions based on their presence.  See section **Role
Detection**

Production playbooks MUST NOT use untagged roles
Production roles MUST be tagged.

The `meta/main.yml` MUST exist and MUST contain a `dependencies` array and
that array MUST be empty. A minimal `meta/main.yml`
might be:

```
# Standards: 1.0

dependencies: []
```

### Tasks and handlers

All tasks and handlers must have a unique name within a role (as names are
prefixed with role in the output, we don't need to worry about uniqueness across
roles). This allows `--start-at-task` to be unambiguous, and also means that
it's easy to see at what point a playbook failed.

Tasks and handlers MUST use yaml dictionaries rather than `key=value` arguments.
This is for readability, simplicity in code reviews (one argument will correspond
with one line in any change), but most importantly code simplicity
(no need to worry about unexpected type conversion of ints to strings)

That is, use:

```
- name: install flooble
  yum:
    state: present
    name: flooble-1.2.3
```

instead of:

```
- name: install flooble
  yum: state=present name=flooble-1.2.3
```

For e.g. `command` or similar modules that take a free-form string in addition
to key-value pairs, use the `args` form:

```
- name: do some stuff
  command: make dontrunifthisishere
  args:
    chdir: /path/to/run/directory
    creates: dontrunifthisishere
```

#### Ordering of elements

Common usage suggests the following order for task elements. Name should be
first, module second. Keep the stuff most important to the module itself
(e.g. `with_` lists, `when` tests, `become_user`) nearest the module,
and things following from the task (`register` results, `notify` handlers)
towards the end.

```
- name: Friendly name for task
  modulename:
    arg: value
  with_items:
  - item1
  - item2
  become_user: a_n_user
  when: test
  register: result
  notify: handler
  tags:
  - tagA
  - tagB
```

### Rolesfile and ansible-galaxy

A playbook should specify its roles using a rolesfile. A roles file might look
like:

```
- src: https://gitlab.infra.prod.eng.rdu2.redhat.com/ansible-roles/nginx.git
  scm: git
  version: v0.2

- src: https://gitlab.infra.prod.eng.rdu2.redhat.com/ansible-roles/repos.git
  scm: git
  version: 0.1

- src: ssh://git@gitlab.infra.prod.eng.rdu2.redhat.com/shared-access/bugzilla-qe.git
  scm: git
```

Note that we are now using the newer yaml syntax, as the old style csv spec
is being deprecated starting with Ansible v2.0 (it will still work with Ansible
v2.0 but you will get a warning message).

To convert an older roles file to a yaml rolesfile, the following works:

```
sed -e 's/git+\([^,]*\)/- src: \1\n  scm: git/' -e 's/,\(.*\)/\n  version: \1\n/' rolesfile > rolesfile.yml
```

The role is then installed under the playbook (so stage will have a different
installation to production - which makes sense, as testing a new version might
be happening in stage)

```
ansible-galaxy install -r playbooks/app/env/rolesfile.yml -p playbook/app/env/roles
```

To upgrade a role (or more importantly, its dependencies), just blow away the
roles directory and rerun the install command. The result of this installation
(i.e. the `playbook/app/env/roles/` subdirectories) SHOULD NOT
be checked into version control, and the latest .gitignore file excludes them.

### Dependencies

While explicitly specifying role dependencies through `meta/main.yml` is
possible, as of v0.8 this practice will cease and we will move to
"documented dependencies".

To use documented dependencies, when including a role, check its README file
and ensure your rolesfile contains the dependency.

The reason for this is that maintaining version consistency across roles and
playbooks proved to be more effort than we gained. Typical problems included:
* Role A depends on Role B. If you want to update Role A to a newer version,
  you need to update Role B's version. And then Role C if that depends on Role
  B.
* Role B depends on Role A. Role C depends on Role A. Both specify different
  versions. Only one of them will win (and no warning will be generated in
  current `ansible-galaxy` command line tool).
* A playbook's rolefile includes Role A and Role B. Role B also depends on
  Role A. Again, if the versions differ, it's not clear which will be used,
  and no warning will be produced.

Role dependencies:
* Roles updated to change to an empty `dependencies` array should have their
  major version bumped.
* Dependencies MUST be documented in the Dependencies section of the README.md
  that lives in the role's root directory.
* If the order of dependencies matter, that order MUST be noted.
* It is then the responsibility of the playbook author to ensure
  that the dependency is included in the playbook's rolesfile.
* Environment specific roles (e.g. backups, monitoring for production)
  can be specified only in the playbook for that environment.
* Edge case such `firewall` make assumptions about how a given component
  is managed.  To ease future transitions tasks relating to these types of roles
  should be isolated into separate task files (e.g. tasks/firewall.yml that is
  included from main.yml).
  * This can be easily located by third parties and modified for their own
    environments.
  * Allows for easy conditional-based callout modification when alternative
    implementations become available (e.g. firewalld options for filtering).


### Role Detection

* Roles may detect presence of other roles by means of a unique header available
  globally.  This is achieved by concatenating the rolename with the keyword
  'capable' in the defaults/main.yml of each role and setting it to true.
  ```
  postgresql_capable: true
  ```
* For playbook development it is often desirable to skip previous roles though
  still be able to make decisions based on whether those roles would be present.
  This can be achieved by commenting out the role from the role section in the
  play and setting the corresponding identifier
  ```
  - hosts: myhosts
    roles:
      # - postgresql
      # - apache
      - myapp
    vars:
      postgresql_capable: true
      apache_capable: true
  ```
* This method is in preference over other methods including checking runtime
  variable role_names[].
* To detect the presence of an adjacent role it should only be tested if it is
  defined
  ```
  - debug: msg="I like postgres"
    when: postgresql_capable is defined and postgresql_capable
  ```
* The value should be set to true for now and extended in the future to convey
  additional information such as version or an array of additional information.


## Modules and plugins

* Modules should be written in python and inherit from `AnsibleModule`.
* Modules should live in the most appropriate place - likely in the `library`
  directory under a role.
* Common modules then live in a common role.
* Plugins should be installed under a `plugins` directory as configured in
  `ansible.cfg`
* Modules and plugins must adhere to
  [PEP 8](https://www.python.org/dev/peps/pep-0008/).
  Use the `pep8` command (from `pip install pep8` or
  `yum install python-pep8`).

## Documentation

* All non-code documentation should be wrapped at 80 characters. This can
  be achieved for new text using `:set textwidth=80` or
  ```
  au BufRead,BufNewFile *.md setlocal textwidth=80
  ```
  in your `.vimrc` file. To re-wrap existing text, use `gq` with a direction
  (e.g. `1GgqG` will rewrap the whole file - but this is typically not what
  you want as it can break lists, code quotes etc.)

## Performance

* Ensure you are using ControlPersist (run ansible-playbook under
  `-vvv` to see your settings). There is a difference of 10x in connection
  times. This happens by default with modern openssh implementations,
  as long as you don't override `connection` in the configuration file.
* Ensure you have `pipelining = True` under your `[ssh_connection]` section
  of ansible.cfg. With pipelining off, transferring the ansible modules can
  take 3 seconds alone. Pipelining on adds to execution time, but to
  nowhere near the same effect.
* Don't use `yum state=latest` if you can use `yum state=present`. Using
  `state=present` combined with a specific version is good configuration
  management practice anyway.

## Continuous Delivery and Integration

* Plays and roles should be able to complete in checkmode (ansible-playbook -C).
  Roles not able to run in checkmode after initial deployment will prevent
  follow up changes from being tested effectively before actual deployment.
  * Plays are not expected to be able to complete in checkmode before the inital
    deployment.
  * Use of 'always_run: true' can be used on tasks that gather facts required for
    subsequent tasks.
  * For actions particular to whether checkmode is in use or not see further below.

* Plays and especially roles should be developed with continuous deliviery in
  mind.  Therefore no play should list any value other than 'changed: 0' in the
  report at the end of the play if no functional changes on the target would
  occur.  In particular, shell and command will always return 'changed'.  Use of
  'changed_when: False' when running read-only commands is encouraged
  to minimise false alarms:

  ```
    - name: verify certificate issuer for optional CA configuration default
      command: openssl x509 -in /etc/httpd/conf/ssl.crt -noout -issuer
      register: crt_verify
      changed_when: false
      always_run: true
  ```

* Other means of reducing the amount of unnecessary changes:
    - use `creates` or `removes` with commands to prevent an action happening
      if it's already happened
    - use `when` with a pre-check task to see if an action needs to happen before
      doing it.

* Checkmode itself can influence how a play completes, having a different impact
  to when it is disabled.  Sometimes we need a play to behave differently in
  this situation.  One way is to trick the command module itself to determine if
  checkmode is set:

  ```
    - name: is check mode on
      local_action: command /bin/true
      register: checkmode_checker
      changed_when: False

    - name: set checkmode variable
      set_fact: checkmode={{checkmode_checker|skipped}}
      changed_when: False

    - name: pause for manual SQL import
      pause:
        prompt: " >>> Import DB SQL, <CR> to resume\n"
      when: not checkmode

    - name: do something only when not in checkmode
      debug:
        msg: " >>> Skipping DB import pause\n"
      when: not checkmode
  ```

## Git best practices

### Branches

Always develop on a branch other than master, even when pushing
to your own fork. 

This has several benefits:
* After pushing a branch named something other than master to
  gitlab, the web interface for the home page or the upstream
  repo will show you a Create Merge Request
  button for the most recent branch you pushed.
* If you accidentally push to the wrong remote, the worst that
  will happen is an unwanted branch
* When creating a MR, the name of the branch is used as the
  subject of the MR. This is often a handy starting point
* When a reviewer wants to review your code on their machine,
  they can do `git fetch yourname` and it will create new local
  branches for all uniquely named branches. This means they
  can just do `git checkout your-new-feature`, rather than
  have to create a new branch based on your branch

### Commits

Ensure that all commits follow best practices for git commits.
One way to achieve this is by running the following in the main
ansible playbooks repo.

```
git config --global commit.template `readlink -fn .commit-template`
```

Other suitable commit templates can be applied if you prefer, as long as they
meet the usual git [best practices](http://chris.beams.io/posts/git-commit/):

* Single subject line, in imperative form, 56 characters or less
* Single blank line
* Description of what is changing, and more importantly, why it is needed
* References (e.g. the ticket that this change resolves)

All commits to the main playbooks and secrets repo must be prefixed with the application,
e.g. `bugzilla: update to version 1.2.3`. Some things are more general, but
choose a loose functional description (e.g. `certs: ` in such cases)

### Rewriting commit history

Maintaining a useful commit log is handy. In general, if you've broken the
work into a bunch of independent, logical commits, there is no need to
squash commits.

Times when rewriting history should be considered:
* A Merge Request contains both a commit and its revert. Just remove both
  using `git rebase -i upstream/master` and deleting both commits.
* A commit message does not meet the standards in the Commits section.
  Use `git rebase -i upstream/master` with the `edit` or `reword` function.
* A commit is so trivial (e.g. fix typo), it would have been better to
  have amended the previous commit. Use `fixup` to merge this into the
  previous commit.  (when making such a commit,
  `git commit --amend --no-edit -a` will just
  merge the change into the previous commit.)
* A Merge Request contains a merge commit. Use `git rebase upstream/master`
  to remove the merge commit.
* If gitlab says a commit can't be merged, rebase using
  `git pull --rebase upstream master` and fix the resulting conflicts.

See [Rewriting
History](https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History) in
the Git book for more details


